# Javacript: Introdu√ß√£o

## Hist√≥ria:

Tudo √© uma evolu√ß√£o/transforma√ß√£o, nada foi criado no zero. Com o surgimento do HTML e do HTTP, especialistas come√ßaram a interagir e evoluir a ferramenta at√© que foi criada a Netscape, uma empresa important√≠ssima que financiou a cria√ß√£o do Live Script, uma linguagem scriptada que focava em dar "din√¢mica" √† pagina est√°tica. Em fun√ß√£o da popularidade da liguagem de programa√ß√£o Java, foi trocado o nome de Live Script para JavaScript (ambas s√£o baseadas em "C", mas completamente diferentes). Para evitar copias e criar um padr√£o no mercado, a Netscape realizou uma parceria com a Ecma International e criou o EcmaScript, que √© o JavaScript usado pelas pessoas atualmente. A vers√£o mais atual do Javascript √© a ES2022 (EcmaScript 2022).

O Javascript, no contexto hist√≥rico, foi criado para melhorar o HTML e na atualidade ainda √© usado para tal, regulando o comportamento dos sites e fazendo uso do Unicode charset. Contudo, com a evoula√ß√£o da linguagem ele passou a poder tamb√©m ser usado fora dos web browsers, atuando no backend de server-side aplications. Existem ainda JavaScript Frameworks, eles s√£o ambientes de devesenvolvimento que ajudam os developers a renderizar e criar coisas (eles facilitam a implementa√ß√£o de coisas ao fornecer uma "estrutura" pr√≥pria).

No passado e ainda hoje utiliza-se Jquery. Jquery √© uma library de JavaScript que foi feita para simplificar e otimizar a manipula√ß√£o HTML DOM, al√©m de ser capaz de fazer anima√ß√µes em CSS e receber e enviar informa√ß√µes de/para bancos de dados atrav√©s do Ajax. OBS: DOM = Document Object Mode. Ele permite que voc√™ trabalhe diretamente com os elementos do html (div, h3, span, etc) sem precisar "converter" ou ter trabalho a mais em JavaScript.

Atualmente exitem ferramentas/frameworks que s√£o muito melhores que Jquery (como Angular, React, Svelte), todos eles facilitando a modifica√ß√£o e implementa√ß√£o de c√≥digo em websites. As principais features de um framework s√£o: Rendering, Data handling e Event handling. Ali√°s, enquanto python usa a "Snake case" (abacate_bonito), JavaScript usa a "Pascal case" (abacateBonito ou AbacateBonito)

## Aprendizado:

O trabalhoso n√£o √© entender a sintaxe, √© desenvolver o pensamento criativo de como resolver um problema real com essa sintaxe.
Voc√™ deve desenvolver a capidade de transformar um texto/pedido em instru√ß√µes, como se fossem uma recita. Depois basta "seguir" essa recita na linguagem de programa√ß√£o e faze com que cada passo se conecte com o anterior.

## "use strict":

√â uma string que voc√™ sempre deve escrever na liha 1 do seu arquivo .js. Basicamente √© respons√°vel por "ativar" funcionalidades modernas do javaScript.

## Erros:

Javacript √© uma linguagem interpretada. Isso significa que, em troca de ter uma sintaxe mais agrad√°vel e flexivel ele vai ter uma performance inferior. Em se tratando dos erros que voc√™ encontrar quando escrevendo em javascript os principais s√£o:

- **syntax errors**: voc√™ escreveu errado e/ou n√£o seguiu a "ortografia" da linguagem.
- **Logical errors**: voc√™ emplementou o c√≥digo em uma logica fundamentalmente errada. O compilador/interpretador vai funcionar mas n√£o do jeito que deveria.

## Operators:

S√£o simbolos que voc√™ pode utilizar para fazer a intera√ß√£o entre duas vari√°veis. Existem os operadores matem√°ticos (que servem para somar, subtrair, etc), os l√≥gicos (Que servem para comparar duas vari√°veis) entre outros. Alguns operadores comuns s√£o encontrados abaixo:

- `!=` (diferente)
- `**` (pontencia√ß√£o)
- `%` (resto da divis√£o)

- `>=` (maior ou igual)
- `<=` (menor ou igual)
- `==` (igual l√≥gico)
- `===` (estritamente igual. Tamb√©m l√≥gico)

- `x += 5` √© o mesmo que `x = x + 5`
- `x /= 5` √© o mesmo que `x = x / 5`
- entre outros

## Variables:

### declara√ß√£o:

A nossa b√°sica √©: Variables s√£o "containers" para values. Variables (e objects) N√£o s√£o seu values, s√£o "espa√ßos" onde eles est√£o armazenados.
Existem 3 formas de declarar uma vari√°vel (criar uma "caixa" vazia que armazena os valores que voc√™ quer):

- `var`: Modo antigo. √â confuso mas tem suas vantagens (ex: hoisting e multiplas declara√ß√µes para uma mesma vari√°vel).

  ```js
  var count = 1;
  var count = 2; //√â permitido
  ```

- `let`: Modo "novo". Faz o mesmo que o var mas n√£o tem hoisting nem √© permitido fazer multiplas declara√ß√µes para uma mesma vari√°vel.

  ```js
  let count = 1;
  let count = 2; // √â proibido
  count = 2; // √â permitido
  ```

- `const`: Cria a vari√°vel do mesmo jeito, mas o value/valor atrelado √† ela n√£o poder√° variar. √â recomendado usar quando os dados s√£o "est√°ticos" (tipo um bot√£o).

  ```js
  const count = 1;
  count = 2; // √â proibido
  ```

Como regra geral, sempre declare vari√°veis como `const` a menos que voc√™ saiba que elas v√£o mudar, nesse caso use `let`.

### Escopos de declara√ß√£o:

Em JS existem tr√™s scopes:

- **Global Scope** (a vari√°vel pode ser usada em todo o c√≥digo)
- **Function Scope** (a vari√°vel s√≥ √© usada dentro de fun√ß√µes)
- **Block Scope** (vari√°veis criadas dentro de "{ chaves }" (block) n√£o podem ser acessadas fora dessa block. Cada bloco √© √∫nico e n√£o precisa de indentifica√ß√£o)

### Data Types:

#### Number:

Esse Data Type √© igual ao "float" do python, com 64 bits de comprimento. Os valores em nota√ß√£o cient√≠fica tamb√©m s√£o do datatype "number". Ex: `const number3 = 3e5 // 3* 10^5`

#### String:

Em JS as aspas normais ('') e as duplas ("") s√£o tratadas como iguais sendo usadas para declarar strings.
As aspas "reversas" (\`\`) s√£o usadas para fazer **template strings** (template Literals). Ex: let x = \`Posso usar o valor dessa ${variavel}\`;

#### Boolean:

S√≥ exitem dois valores poss√≠veis, true ou false. Normalmente usada em alguma express√£o com operadores logicos.

#### Symbol:

√â um valor √∫nico que voc√™ obtem atrav√©s de uma string. Voc√™ n√£o pode ver o valor/conte√∫do de uma symbol, √© como se fosse um uid.
Dois symbols de uma mesma string n√£o s√£o iguais. O objetivo dos symbols √© tratar dados de maneira mais discreta (privacidade) mas n√£o s√£o "fortes" o suficiente para tal, sendo necess√°rio usar proxies e outras tecnologias em um app profissional.

#### Objects:

Objects armazenam os dados em key/value pairs. As keys tem que ser strings e os values podem ser qualquer outros data type (at√© mesmo outros objects ou alguma fun√ß√£o. S√£o criados ao usar chaves ({}).

```js
let object = {
  key1: "value",
  key2: 5,
};
```

#### Undefined:

√â a variable global que representa a n√£o exist√™nicia de dados. Quando voc√™ faz `let x;` Voc√™ est√° dizendo que x existe, mas n√£o est√° dando um valor para ele.
At√© que um valor seja atribuido √† x ele ser√° reconhecido como "undefined". A keyword `void` pode ser usada para ignorar o output associado a uma express√£o e ent√£o retornar "undefined". A sintaxe √© `void <expression>`.

```js
function f() {
  document.body.style.backgroundColor = "red";
  document.body.style.color = "white";
} //a fun√ß√£o √© totalmente funcional
let vari = undefined === void f(); //Como "void f()" √© undefined ent√£o vari = true
alert(vari);
```

#### Null:

Normalmente √© usada para indicar falta de "indentidade", ou ent√£o quando uma vari√°vel vai ter um valor no futuro, mas n√£o tem agora. Por exemplo `let x = null;`

### Hoisting:

Hoisting se refere ao processo, realizado pelo interpretador da linguagem, de mover as Declara√ß√µes de fun√ß√µes, vari√°veis e classes para o topo de seus respectivos escopos, antes de serem executados.

#### Em fun√ß√µes:

```js
//O "correto" seria escrever a fun√ß√£o primeiro e depois "chamar" ela, mas:

catName("Tiger");

function catName(name) {
  console.log("My cat's name is " + name);
}
//O c√≥digo acima roda, mesmo que a fun√ß√£o seja chamada antes de ter sido declarada. Output: "My cat's name is Tiger"
```

#### Em vari√°veis:

Basciamente s√≥ quando voc√™ declara vari√°veis com o "var" que o hoisting √© poss√≠vel, por√©m diferente do modo que acontece com as fun√ß√µes.

```js
console.log(num);
/* Vai retornar 'undefined' (e n√£o 6), porque o hoisting feito pelo var √© de "declara√ß√£o", ou seja, ele s√≥ declara a vari√°vel "num"
    (e como n√£o atribui um valor a ela, ela fica como undefined) */
var num = 6; // Initialization and declaration.
console.log(num); // vai retornar/printar 6 pois √© executada depois da linha de declara√ß√£o e Atribui√ß√£o.
```

## Condicionais:

No JS cl√°ssico existem 2 modos de fazer condicioais

1. If..Else

```js
if (choice === 'sunny' && temperature < 86) { //ap√≥s o if, entre paranteses est√° a condi√ß√£o. Se ela for verdadeira o bloco de c√≥digo √© executado
//OBS: && = AND e || = OR
//some code
} else if (choice === 'sunny' && temperature >= 86) { //else if, voc√™ j√° sabe como funciona
//other code
} else {
break;
}
```

2. Switch..Case

```js
let variavel = 50;
switch (typeof variavel) {
  case "number":
    alert("1");
    break;
  case "string":
    alert("2");
    break;
  default:
    //default code
    break;
}
```

3. Operador tern√°rio

```js
let a = "Abacte";
let b = a === "Coxinha" ? "yes" : "no";
```

## Loops/La√ßos:

1. For

```js
for (let i = 0; i < 5; i++) {
  console.log("ABACATE");
}
```

2. While

```js
let i = 0;
while (i < 5) {
  console.log("ABACATE");
  i++;
}
```

3. Do..While

```js
let i = 0;
do {
  console.log("ABACATE");
  i++;
} while (i < 5);
```

- 4. For..In (itera√ß√£o dentro de uma cole√ß√£o/objeto)

```js
const a = {
  type: "a",
  id: 5031,
};
for (let key in a) {
  console.log(a.id);
  //vai dar o resultado duas vezes porque tem 2 keys
}
```

- 5. For..of (itera√ß√£o dentro de arrays)

```js
const cores = ["abacate", "2"];
for (let cor of cores) {
  console.log(cor);
}
```

## Functions:

S√£o blocos de c√≥digo indentados (dentro de chaves {}) e que s√≥ s√£o executadas quando s√£o invocadas (algum outro comando ou evento a executa) ou quanto se auto-invocam (executam "automaticamente"). Voc√™ deve criar fun√ß√µes/blocos de c√≥digos auto contidos para seus prop√≥sitos (n√£o crie fun√ß√µes muito grandes ou que acessam muitas coisas, d√™ prioridade √† criar outra fun√ß√µes).

```js
function convertToFahrenheit(celsius)
{
return ((9/5) \* celsius) + 32
let variable = "abacate" === "coxinha" //A fun√ß√£o vai ignorar essa linha pois ela esta depois do "return" e no mesmo bloco (de codigo), ou seja, vai ser pulada/ignorada.
}
alert(convertToFahrenheit(5))
alert(variable) //como "variable" n√£o foi atrubida, nada acontece.
```

### Arrow functions:

√â uma nota√ß√£o mais consisa que visa compactar a declara√ß√£o de fun√ß√µes. Outro detalhe √© que arrow functions n√£o tem um "this." pr√≥prio, isso significa que a fun√ß√£o n√£o consegue entender/encontrar o "contexto" em que est√°. Gra√ßas a essa funcionalidade arrow functions s√£o normalmente usada para declarar fun√ß√µes de callback (que s√£o passadas para outras fun√ß√µes como par√¢metro para serem executadas no final da execu√ß√£o da primeira).

```js
const array = [
  { id: 1, name: "a" },
  { id: 2, name: "b" },
];
console.log(
  array.find((array) => {
    return array.name === "a";
  })
);
```

### Rest parameters:

O s√≠mobolo `...` pode ser tanto **rest paramenter** quanto **spread operator**, dependendo do contexto.

√â **rest parameter** quando voc√™ o usa como argumento. Basicamente √© utilizado para passar argumentos "infinitos" para uma fun√ß√£o.

```js
function sumAll(...args) {
  // args is the name for the array
  let sum = 0;
  for (let arg of args) {
    sum += arg;
  }
  return sum;
}
alert(sumAll(1)); // 1
alert(sumAll(1, 2)); // 3
alert(sumAll(1, 2, 3)); // 6 ##
```

√â **spread operator** quando voc√™ usar ele na atribui√ß√£o de coisas. Basicamente serve para copiar/concatenar/manipular objects e arrays.

```js
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];
let merged = [0, ...arr, 2, ...arr2];
alert(merged); // 0,3,5,1,2,8,9,15
```

### Callbacks:

Callback √© um termo utilizado normalmente quando se trabalha com async/await, mas, basicamente, consiste em chamar um fun√ß√£o dentro de outra fun√ß√£o, criando uma rela√ß√£o de dependencia/sequencia l√≥gica de eventos.

```js
function preProducao(arg1, iniciar_producao) {
  if (arg1 === "iniciar") {
    iniciar_producao();
  }
}

function initProducao() {
  alert("doing something");
}

preProducao("iniciar", initProducao);

//repare que a fun√ß√£o que inicia a produ√ß√£o s√≥ come√ßa/ocorre quando a fun√ß√£o "preProducao" da a liberdade/ordem de iniciar.
```

### Recursion and stack:

Recursividade √© um programming pattern usado para deixar o c√≥digo mais limpo ou fazer algo mais simples de intender. Consiste basicamente em, dentro de uma fun√ß√£o, chamar a pr√≥pria fun√ß√£o. Vejamos dois modos diferentes de criar uma mesma fun√ß√£o:

```js
//Com o for loop
function pow(x, n) {
  let result = 1;
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  return result;
}
```

```js
//Com recursividade
function pow(x, n) {
  if (n == 1) return x;
  else return x * pow(x, n - 1);
}
```

Mais detalhadamente, quando uma fun√ß√£o √© executada, as informa√ß√µes dela (como o valor de this ou de outras vari√°veis) s√£o armazenadas em uma data structure especial chamada de **execution context**.
Quando uma fun√ß√£o √© chamada dentro de outra fun√ß√£o (caso da recursividade), o execution context mais externo √© pausado e um novo √© criado. Essa din√¢mica de "pausar" e criar outro em cima funciona na base de stacks (pilhas).
Basta perceber que o primeiro execution context vai ser o ultimo a ser retornado pois todos os outros que vieram depois dele precisam ser "retirados" antes de modo que o mais externo possa voltar a ser executado.
Como criar execution contexts demanda mem√≥ria, voc√™ n√£o pode se dar ao luxo de fazer isso v√°rias vezes. No caso da fun√ß√£o "pow" v√£o ser criadas "n" execution contexts.
Todas as fun√ß√µes recursivas podem ser reescritas como loops, e loops consumem/precisam de menos mem√≥ria. Entretando contruir um loop complexo √© uma tarefa mais dif√≠cil.

### Scheduling:

fun√ß√µes que permitem que outras fun√ß√µes rodem depois de um certo tempo. Serve para simular uma "chamada assincrona".

- setTimeout: permite rodar uma fun√ß√£o depois de um certo tempo.

```js
function sayHi() {
  alert("Hello");
}

setTimeout(sayHi, 1000);
//1000ms = 1 segundo
```

- setInterval: permite rodar uma fun√ß√£o dado um periodo, se repetindo regularmente.

```js
let timerId = setInterval(() => alert("tick"), 2000);
//vai rodar a cada 2 segundos. Al√©m disso √© infinito, ou seja, n√£o vai parar.
// Temos que parar "manualmente" usando o setTimeout e clearInterval.
setTimeout(() => {
  clearInterval(timerId);
  alert("stop");
}, 5000);
```

### Function biding:

Basicamente, quando queremos passar uma key/value de um objeto em uma fun√ß√£o(callback) e esse key/value usa o "this", o "contexto" do "this" √© perdido.
Em outras palavras, a fun√ß√£o que recebe um objeto como argumento n√£o faz a minima ideia sobre o que "this" √©.
Para resolver isso podemos usar um wrapper, ou seja, criar uma "lambda function" que salva o "contexto" do this e ent√£o passa ele para a outra fun√ß√£o. Esse metodo tem vulnerabilidades, sendo recomendado usar o method bind.

O method bind basicamente vai pegar uma fun√ß√£o, "juntar" o seu contexto(objeto ou qualquer outra coisa que o .this se refere) e ent√£o criar um objeto especial que pode ser chamado(callback) como uma fun√ß√£o.

```js
function hash(arguments) {
  return arguments[0] + "," + arguments[1];
}

//decorator
function cachingDecorator(func, hash) {
  let cache = new Map();
  return function () {
    let key = hash(arguments);
    if (cache.has(key)) return cache.get(key);
    else {
      let result = func.call(this, ...arguments);
      cache.set(key, result);
      return result;
    }
  };
}

//objeto com o m√©todo que ser quer fazer o cache
let worker = {
  slow(min, max) {
    console.log("Working...");
    return min + max;
  },
};

worker.slow = cachingDecorator(worker.slow, hash);
let start = new Date();
worker.slow(3, 5);
let end = new Date();
console.log(`Demora: ${end - start}ms`);

start = new Date();
worker.slow(3, 5);
end = new Date();
console.log(`Demora (cached): ${end - start}ms`);
```

Esse exemplo √© um pouco mais complexo. Se tiver dificuldade de entender o porque da utiliza√ß√£o da fun√ß√£o hash(), d√™ uma olhada [aqui](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments).

## Objects:

A analogia √© perfeita: Um carro √© um objeto.

- Todos os carros tem as mesmas properties (cor, tamanho, peso) mas seus values s√£o diferentes
- Todos os carros tem os mesmos methods (ligar, freiar, etc) mas eles s√£o acionados em momentos diferentes.

√â uma boa pr√°tica usar a keyword "const" para definir/declarar um objeto, por√©m objetos em JS s√£o especiais por serem din√¢micos (podem ser alterados) e portanto isso fica a crit√©rio pr√≥prio. Voc√™ pode declarar/criar um objeto de duas formas:

```js
let user = new Object(); // "object constructor" syntax
let user = {}; // "object literal" syntax
```

Voc√™ pode acessar o valor de uma propertie de duas formas:

- objectName.propertyName (ex: car.color)
- objectName["propertyName"] (ex: car["type"])

Methods s√£o as fun√ß√µes/a√ß√µes que aquele objeto possue/cotem e portanto pode executar. Basta criar/declacar o value de uma key como uma function:

```js
const person = {
  firstName: "John",
  lastName: "Doe",
  id: 5566,
  fullName: function () {
    return this.firstName + " " + this.lastName; // repare na indenta√ß√£o
  },
};
```

### Computed properties:

Voc√™ pode dar o nome de uma key de forma din√¢mica (mais n√£o pode acessar esse nome de forma din√¢mica).

```js
let fruit = prompt("Which fruit to buy?", "apple");
let bag = {
  [fruit]: 5, // o nome da key √© o valor da vari√°vel "fruit"
};
alert(bag.apple); // Por√©m para fazer o alert nos precisamos saber e especificar qual o nome da key ("bag.[fruit]" n√£o funciona).
```

### Criando objetos dinamicos com "this":

Voc√™ pode usar a keyword `this` dentro de um method de modo a receber um valor do prompt. Depois de chamar esse m√©todo, voc√™ pode armazenar esse valor "dinamicamente" como um value. Dentro de um objeto.

```js
let person = {
  name: this.name,
  age: this.age,
  email: this.email,
  readData() {
    this.name = +prompt("Diga seu nome");
    this.age = +prompt("Diga sua idade");
    this.email = +prompt("Diga seu email");
  },
};
person.readData(); //vai fazer os prompts e pegar os dados

if (person.age < 18) {
  alert(`Ol√° ${person.name}, infelizmente voc√™ n√£o pode entrar =(`);
} else {
  alert("ABACATE");
}
```

### ‚Äúfor‚Ä¶in‚Äù loop:

Basicamente voc√™ pode iterar dentro de um objeto/array. No caso dos objetos √© importante prestar aten√ß√£o na sintaxe para diferenciar as keys dos values:

```js
let user = {
  name: "John",
  age: 30,
  isAdmin: true,
};

for (let key in user) {
  // keys
  alert(key); // name, age, isAdmin
  // values for the keys
  alert(user[key]); // John, 30, true
}
```

### Copiando objetos:

Basciamente se voc√™ tem um objeto e voc√™ cria outra vari√°vel e iguala ele a esse objeto, voc√™ n√£o est√° fazendo uma c√≥pia independente, est√° criando uma nova referencia para o objeto. Para efetivamente clonar um objeto pode-se usar o method "Objct.assign":

```js
const oldObj = { abacate: 1, sim: false };
const newObj = Object.assign({}, oldObj); //{} significa que copia todo o objeto.
console.log(oldObj);
console.log(newObj);
```

### Object.keys, values, entries:

Como objects s√£o bastante flexiveis e podem se tornar complexos, existe uma "entidade" chamada de Object que se refere a estrutura do objeto.

- Object.keys(obj) retorna uma array com as keys.
- Object.values(obj) retorna uma array com os values.
- Object.entries(obj) retorna o key/value pair em forma de array.

E como o resultado desses methods s√£o arrays, voc√™ pode fazer uma itera√ß√£o sobre eles.

### Object destructuring:

Consiste em "desmantelar" partes de um objeto e atribuir a novas vari√°veis:

```js
let options = {
  size: {
    width: 100,
    height: 200,
  },
  items: ["Cake", "Donut"],
  extra: true,
};

let {
  size: { width, height },
  items: [item1, item2],
  title = "Menu", // campo n√£o presente no objeto (recebe valor atribuido)
} = options; //repare que options √© nome do objeto base

alert(title); // Menu
alert(width); // 100
alert(height); // 200
alert(item1); // Cake
alert(item2); // Donut
```

### Factory function:

√â uma fun√ß√£o que cria um objeto.

```js
function abc(prop1, prop2, prop3) {
  return {
    keyUm: prop1,
    keyDois: prop2,
    keyTres: prop3,
  };
}
const obj1 = abc(1, 2, 3);
console.log(obj1);
```

### Constructor Functions:

Tamb√©m √© utilizada para criar objetos, por√©m ela √© como se fosse um "classe" do python (um blueprint para objetos). Utiliza o "new" para criar um elemento dessa "classe".
Normalmente constructor functions come√ßam com letra mai√∫sculas para se diferenciar. Repare que, enquanto as factory functions usam "return" para se referir aos seus par√¢metros, uma constructor function utiliza o "this." para se referir ao seus par√¢metros.

```js
function objMaker(prop1, prop2, prop3) {
  this.keyUm = prop1;
  this.keyDois = prop2;
  this.keyTres = prop3;
  this.methodUm = function () {
    console.log("methodUm");
  };
}

const obj1 = new objMaker("Abacate", "ABACATE", "a b a c a t e");
console.log(obj1);
```

### OOP:

Quando voc√™ usa objetos para representar entidades(fun√ß√µes, uma parte da mem√≥ria, etc) voc√™ est√° realizando/fazendo: object-oriented programming.
Essa abordagem √© vers√°til e amplamente utilizada por programadores. √â como se fosse "o jeito de certo de cal√ßar um sapato".
Voc√™ pode cal√ßar de diferentes formas, mas noramlmente voc√™ vai querer/preferir cal√ßar do "jeito certo".
Isso √© t√£o verdade que foi da√≠ que o conceito de Design patterns foi criado. Isso basicamente se refere a um conjunto de estrat√©gias/modos de resolver problemas comuns/recorrentes usando OOP.

### Chaining:

√â quando voc√™ faz `obj.prop1.prop2.method1.method2`, tipo, voc√™ vai fazendo v√°rios `.algumaCoisa` seguidos. Isso pode ser √∫til em algumas situa√ß√µes.
Por exemplo, existem situa√ß√µes onde vamos precisar usar o n√∫mero da casa de um usu√°rio atrav√©s de: `user.adress.street.number`. Reparem que tem 4 properties a√≠.
Basciamente para que voc√™ possa usar chaining voc√™ deve rotornar o pr√≥prio objeto (e deixar para fazer o output separadamente), de modo que o pr√≥ximo `.algumaCoisa` vai se referir ao objeto recem alterado. Usa-se `return this`;

#### Optional chaning:

As vezes, alguams informa√ß√µes s√£o opcionais, de modo a n√£o existencia delas faz o c√≥digo parar por causa do erro. √â melhor retornar undefined que parar todo o programa.
Tipo, no exemplo anterior, pode ser que o user tenha dado o n√∫mero da casa dele, mas n√£o tenha dado a rua, isso vai gerar um erro que vai parar todo o c√≥digo. N√£o queremos isso.
Para evitar o erro, e retornar `Undefined`, precisamos usar o operador `?.`. Ele S√ì DEVE ser usado quanto uma property possa ser nula.
Ex: `user.adress.street?.number`. Dessa forma, a obten√ß√£o de `street` vai ser opcional, de modo que se ELE n√£o existir, o c√≥digo simplismente retorna undefined.
Repare que √© s√≥ ele. Se user, adress ou number n√£o existirem, o c√≥digo vai dar erro de qualquer jeito. Ent√£o, o que fazer? Usar `?.` nos elementos certos e fazer um c√≥digo limpo.
O elemento que est√° antes(a esquerda) do `?.` deve existir/ser declarado, so n√£o precisa ter um valor. O `?.` n√£o pode ser usado para ler valores, tipo, deixar a entrada de um par√¢metro como opcional. Essa funcionalidade existem em frameworks e no JS atrav√©s de outras formas.

### JSON:

JavaScript Object Notation foi criada, como o nome ja diz, para se transmitir o conte√∫do de objetos do javaScript atrav√©s da internet(HTTP). Com o passar to tempo a formata√ß√£o se formou padr√£o para transmiss√£o de dados na internet e √© usada em outras linguagens.
No javaScript, JSON basicamente √© a convers√£o de um objeto para uma string, com uma formata√ß√£o especial. Para fazer essa convers√£o usamos JSON.stringify(obj);
Esse method ignora certas properties, como methods, symbolic keys/values e o null.

```js
let student = {
  name: "John",
  age: 30,
  isAdmin: false,
  courses: ["html", "css", "js"],
  wife: null,
};

let json = JSON.stringify(student);

alert(typeof json); // we've got a string!

alert(json);
```

Para fazer o caminho inverso (JSON -> object "nativo") usamos: JSON.parse.

```js
let userData =
  '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';
let user = JSON.parse(userData);
alert(user.friends[1]); // 1
```

### Garbage collection:

Diferente da linguagem C, onde a a mem√≥ria deve ser monitorada e controlada cautelosamente, o javaScript possue um algor√≠timo interno que realiza limpeza de mem√≥ria de modo a "deletar" partes do c√≥digo que s√£o/ficam in√∫teis.
Em JS objetos(quase tudo) s√£o mantidos na mem√≥ria enquanto eles s√£o "alcan√ßaveis" pelo "root" do JS, que √© chamado de `<global>`.
Ou seja, se voc√™ diz que algo √© null e ele n√£o √© percebido pelo `<global>` (n√£o √© passado como argumento, n√£o serve de base para uma vari√°vel, etc), ent√£o ele ser√° deletado.
E, analogamente, se algo √© usado definido como null, √© passado como par√¢metro E tem conexa√ß√£o com o `<global>` ent√£o ele n√£o ser√° deletado.
Importante notar a utiliza√ß√£o do "E" na ultima linha pois, n√£o basta que o objeto esteja ligado √† outro, ele TAMB√âM precisa estar ligado at√© o `<global>`, otherwise ele e os outros objetos que est√£o ligados √† ele seriam "Unreachable islands"

## Prototypes & inheritance:

√â um modo/metodo em programa√ß√£o no geral que permite estender funcionalidades/objetos existentes.
Imagine que voc√™ tem um objeto chamado de user e que voc√™ quer criar outros 2: admin e guest. Independente de como voc√™ vai criar esses objetos ambos v√£o ser users, concorda?
Dessa forma podemos usar o objeto user que j√° existe e estender ele de modo a reusar algumas partes dele e implementar outras partes dentro de cada objeto.

### Prototype (proto):

Em JS existe um propriedade escondida dos objetos chamada de `[[Prototype]]` que aponta para "null" ou para outro objeto.
Basicamente quando voc√™ cria um objeto, `[[Prototype]]` √© como se fosse o DNA herdado do objeto. Como, naturalmente objetos n√£o herdam caracteristicas de outros objetos, logo `[[Prototype]` √© naturalmente null.
Para mudar o valor de `[[Prototype]]` e fazer ele apontar para outro objeto, podemos usar o **proto**. Vamos usar ele nesses exemplos iniciais, por√©m ele est√° em desuso

```js
//objeto "inicial"/acestral
let animal = {
  eats: true,
  walk() {
    alert("Animal walk");
  }
};

//objeto "descendente". Queremos que ele herde as properties de "animal"
let rabbit = {
  jumps: true,
  **proto**: animal //basta passar um link/DNA do objeto "animal" e agora o obj "rabbit" tamb√©m possue essas properties
};

//Outro objeto. Uma esp√©cie de coelho. Ele √© claramente um coelho E um animal
let longEar = {
  earLength: 10,
  **proto**: rabbit //como rabbits j√° tem o "DNA" de um animal, basta ter o DNA do "rabbit"
};

longEar.walk(); //Naturalmente n√£o tem property "walk", √© pega do obj "animal"
alert(longEar.jumps); //Naturalmente n√£o tem property "jump", √© pega do obj "rabbit"
```

### F.prototype:

Voc√™ tamb√©m pode herdar properties sem usar o **proto**. Basta usar a "new" sintax e usar o method ".prototype"

```js
//obj "original"/ancestral
let animal = {
  eats: true,
};

//constructor function.
function Rabbit(name) {
  this.name = name;
}

//dizendo que os objs criados apartir constructor function "rabbit" s√£o descendentes de "animal"
Rabbit.prototype = animal;

let rabbit = new Rabbit("White Rabbit"); //criando um objeto "diferenciado"
alert(rabbit.eats); // true
```

### Substitutos do **proto**:

Como citado, o **proto** est√° em desuso e existem m√©todos mais modernos de se definir o prototype de um objeto:

- `Object.create(ancestral, [descriptors])` cria um obj vazio com o prototype do obj "ancestral"
- `Object.getPrototypeOf(obj)` retorna o `[[Prototype]]` do obj.
- `Object.setPrototypeOf(obj, ancestral)` atribui o `[[Prototype]]` do obj ao do "ancestral".

```js
//obj "acestral"
let animal = {
  eats: true,
};

// criando um novo obj, vazio, como mesmo DNA/properties que "animal"
let rabbit = Object.create(animal);
//repare na utiliza√ß√£o da "entidade" "Object".

alert(rabbit.eats); // true
alert(Object.getPrototypeOf(rabbit) === animal); // true
Object.setPrototypeOf(rabbit, {});
```

## Classes:

### sintaxe e conceitos b√°sicos

Classes s√£o um conceito utilzado em OOP que serve para criar objetos padronizados/com um conjunto inicial de dados semelhantes. O objetivo das classes √© focar mais na utiliza√ß√£o dos methods. Uma observa√ß√£o importante √© que: voc√™ n√£o deve colocar virgulas para separar os methods. O method fundamental das classes √© o "constructor". √â dentro dele que voc√™ coloca as "key/values" que o objeto vai ter.

```js
class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    alert(this.name);
  }
}

let user = new User("John");
user.sayHi();
```

Classes s√£o uma maneira mais simples e vers√°til de se usar constructor functions (que j√° foram citadas no ca·πïitulo sobre objetos). Na realidada, uma classe √© uma constructor function que possue um prototype. Dentro de uma classe voc√™ tamb√©m pode criar key/values diretamente, mas isso √© "restritivo" uma vez que esse mesmo valor de se repete para todos os objetos.

#### static properties:

S√£o properties que n√£o s√£o de um objeto, mas sim a toda a classe. Pode-se dizer que s√£o properties que todos os objetos tem porque a pr√≥pria classe o tem. Para criar ele dentro da classe, voc√™ usa a keyword `static`.

#### getters/setters:

**getter**: √© um method que usa da keyword `get` para retornar/mostrar um valor de objeto/classe de forma din√¢mica. Ou seja, de um valor que ainda n√£o foi definido.
As fun√ß√µes criadas com o get n√£o podem ter nenhum par√¢metro.

**setter**: √© um method que usa a keyword `set` e serve para criar/alterar um valor dentro de um objeto/classe.
As fun√ß√µes criadas com o set s√≥ podem ter exatamente 1 par√¢metro.

S√≥ deixando claro, get e set s√£o keywords que servem para criar fun√ß√µes com prop√≥sitos espec√≠ficos.

```js
class Aluno {
  // usando um constructor para definir as key/values iniciais.
  constructor(nome, curso, semestre) {
    (this.nome = nome), (this.curso = curso), (this.semestre = semestre);
  }
  // criando um method para retornar o nome do aluno antes mesmo dele ser definido
  get nomeAluno() {
    return this.nome;
  }
  //criando um nome para o aluno se ele n√£o existir e alterando se existir
  set nomeAluno(nomeAluno) {
    this.nome = nomeAluno;
  }
}

let lucas = new Aluno("", "Engenharia", 5);
lucas.nomeAluno = "Lucas";
console.log(lucas.nome); //Lucas
lucas.nomeAluno = "Abacate";
console.log(lucas.nomeAluno); // "Abacate" usando getter
```

### Class inheritance

Lembra do que falamos sobre prototypes? Vamos usar isso aqui. Basicamente para fazer uma classe herdar methods e properties de outra classe basta voc√™ usar a keyword "extends".

```js
//classe normal
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name} runs with speed ${this.speed}.`);
  }
}
//cria√ß√£o de uma classe que herda coisas de "Animal"
class Rabbit extends Animal {
  hide() {
    alert(`${this.name} hides!`);
  }
}

let rabbit = new Rabbit("White Rabbit");
rabbit.run(5); // White Rabbit runs with speed 5.
rabbit.hide(); // White Rabbit hides!
```

Entrentanto as coisas n√£o s√£o t√£o simples. Repare que essa classe "Rabbit" n√£o possue um constructor. E se possuisse? Bom, ocorreria um conflito do "this".
Basicamente voc√™ precisa saber de 3 coisas:

1. quando voc√™ criar cria uma classe sem constructor, ele existe, mas est√° vazio.
2. a classe que herdou coisas sempre vai dar prioridade a seus proprios elementos, s√≥ depois usando os herdados (caso tenham o mesmo nome)
3. Para que "o que herdou" se refira a seu ancestral utiliza-se o method super(). Dessa forma, se a classe ancestral e a descendente possuem o mesmo nome em suas properties, e voc√™ que usar a do ancestral, deve usar "super(prop)";

```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
}

class Rabbit extends Animal {
  constructor(name, earLength) {
    super(name); //vai usar o constructor ancestral para criar o nome
    this.earLength = earLength; // property especifica dessa classe
  }
}

let rabbit = new Rabbit("White Rabbit", 10);
alert(rabbit.name); // White Rabbit
alert(rabbit.earLength); // 10
```

### Private/protected

√â algo fundamental quando voc√™ est√° criando coisas complexas/ que usam ou se comunicam, protengendo elas de serem alteradas.
Uma analogia seria com uma cafeteira. Ela √© um objeto complexo, tranforma a corrente alternada em corrente cont√≠nua e depois tranforma em calor e etc.
Entretanto, para o usu√°rio isso n√£o importa, o que importa √© que ele coloca √°gua em um lugar, p√≥ em outro e ent√£o aperta um bot√£o.
Esse √© o tipo de prote√ß√£o/abstra√ß√£o.

- Internal interface ‚Äì methods and properties, accessible from other methods of the class, but not from the outside.
- External interface ‚Äì methods and properties, accessible also from outside the class.

Para fazer essa prote√ß√£o n√£o existe um method ou fun√ß√£o especifica. Basicamente voc√™ tem que usar seu conhecimento para tal.
Usar condicionais para controlar o valor de algo, usar um get e n√£o usar um set para tornar a property read-only. Etc;
Na realidade, n√£o h√° necessidade de usar set/get, desde que voc√™ tenha um controle maior no momento de criar a fun√ß√£o.
OBS: √© uma conven√ß√£o usar `*` no nome de properties protegidas;

```js
class CoffeeMachine {
  *waterAmount = 0;
  set waterAmount(value) {
    if (value < 0) {
      value = 0;
    }
    this.*waterAmount = value;
  }

  get waterAmount() {
    return this.*waterAmount;
  }

  constructor(power) {
    this.*power = power;
  }

  get power(){
    return this.*power;
  }

}

// create the coffee machine
let cafeteira = new CoffeeMachine(100);

cafeteira.waterAmount = -10;
alert(cafeteira.waterAmount)
cafeteira.waterAmount = 23;
alert(cafeteira.waterAmount)
alert(cafeteira.power);
cafeteira.power = 200;
alert(cafeteira.power);
```

## Error handling:

√â impossivel fazer codigo sem erro. O intuito de cuidar dos erros e passar um auxilio personalizado ao usu√°rio e impedir que todo o script morra.
Como j√° dito, se um erro ocorre Todo o script/codigo para. Isso √© ruim. N√≥s queremos fazer com que o c√≥digo continue apesar dos erros. Para isso podemos utilizar o "try...catch"

### try...catch:

√â uma especie de condicional que funciona sincronamente, para cuidar de erros.

```js
try {
  //code to run
  alert("Start of try runs");
  alert("End of try runs");
} catch (err) {
  //error handling
  alert('This "Catch" will be ignored if there is no errors');
}
```

O argumento "err" pode ter qualquer nome. Ele na realidade representa um objeto que vai possuir informa√ß√µes sobre o erro.
Existem alguns methods que podemos usar nesse objeto:

- `err.name; // Error name`
- `err.message; // Textual message about error details.`

N√≥s tamb√©m podemos criar pontos de verifica√ß√£o e se o c√≥digo n√£o passar neles podemos "jogar" um erro usando throw. Normalmente voc√™ tamb√©m precisa criar um error objet ao usar o "Error", "SyntaxError" ou etc

```js
let json = '{ "age": 30 }';
try{
let user = JSON.parse(json);
if(!user.name){
throw new SyntaxError("Dados incompletos. Nome n√£o dispon√≠vel");
}
alert("user.name); //s√≥ vai ser executado se o throw n√£o ocorrer. Ele √© como se fosse um return.
} catch(err){
alert("O seguinte erro ocorreu: " + err.message);
}
```

### finally:

Assim como em python, tamb√©m existe a keyword "finally". Ela vai ser executada tamnto depois do try quanto depois do catch.
OBS: Existe um built-in error object chamado de "Error"
OBS: Como erros s√£o objetos com informa√ß√µes, voc√™ pode criar e estender respostas para certos tipos de erro. Tendo cuidado quando for usar a property "name", n√£o esquecendo de usar o "super()".

## Promises, async/await

### Callbacks:

No mundo real as coisas n√£o ocorrem imediatamente. Por exemplo, se seu computador √© lento e voc√™ quer fehcar o google e abrir um jogo, o jogo n√£o vai esperar o google fechar para poder abrir.
Podemos dizer que a atividade de fechar o google n√£o ocorre imediatamente, e o jogo n√£o espera ela acontecer.
Vamos trazer isso para o javaScript:

```js
//fun√ß√£o que vai criar um tag <script> no html, dado o path at√© a .js file
function loadScript(src) {
  let script = document.createElement("script");
  script.src = src; //src √© uma property do elemento script, que √© representado pela vari√°vel script
  document.head.append(script);
  //inicando o carregamento do script com esse path
  loadScript("/my/script.js");
  //dentro desse script existe uma fun√ß√£o chamada de func123();
  func123(); //gera uma erro, pois o carregamento n√£o ocorre automaticamente
}
```

Para executar a fun√ß√£o desse script no exato momento em que ele carregar precisamos de um callback, uma afirma√ß√£o que diz: "pronto, j√° pode rodar".
Para criar/gerar uma calback voc√™ precisa:

1. Na fun√ß√£o que precisa do callback(loadScript) adicinar outro par√¢metro, que ser√° o callback
2. usar o ".onload" method para rodar o calback, usando a keyword "callback()"
3. Quando chamar a fun√ß√£o, detalhar como a callbakc funcionar√°:
   ```js
   //modificando a fun√ß√£o para que ela possa usar um callback
   function loadScript(src, callback) {
    let script = document.createElement('script');
    script.src = src;
    script.onload = () => callback(script);
    //quando o script carregar, voc√™ vai rodar a fun√ß√£o chamada de callback e passar esse pr√≥prio script como argumento
    script.onerror = () => callback(new Error("Ocorreu um erro durante o carregamento do script"));
    document.head.append(script);
   }
   //Criando manualmente a callback dessa fun√ß√£o. Quando o script carregar essa fun√ß√£o vai rodar.
   function callback(script){
    alert(`Cool, the script ${script.src} is loaded`);
    alert( * ); // function declared in the loaded script
   }
   loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', callback);
   ```

Normalmente voc√™ n√£o precisa criar uma fun√ß√£o separada chamada callback, sendo uma arrow function anonima.
A ideia de callback √©: eu vou executar isso necessariamente depois disso. Em uma esp√©cie de ordem/cadeia.

Entretanto existe um problema com esse c√≥digo, ele n√£o tem controle sobre erros. Veja uma maneira mais consisa e "correta":

```js
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  //A fun√ß√£o callback vai ter dois parametros agora. O primeiro √© um erro e o segundo o script
  //Se o script conseguir carregar, o primeiro argumento √© nulo e tudo ocorre naturalmente
  script.onload = () => callback(null, script);
  //se o ocorrer erro, s√≥ vamos passar o primeir argumento, e ele vai ser um erro.
  script.onerror = () => callback(new Error());
  document.head.append(script);
}
// aqui passamos a fun√ß√£o callback como uma arrow anonymous function.
//repare que passamos dois argumentos (o erro, o script).
loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', (error, script) => {
if(error){
  alert("Deu pepino");
}else{
  alert(`Cool, the script ${script.src} is loaded`);
  alert( * ); // function declared in the loaded script
}
});

```

### Promises:

Imagine que voc√™ √© um cantor e seus f√£s enchem seu saco por m√∫sica novas. Da√≠ voc√™ promete pra eles que voc√™ vai mandar assim que estiver pronto, mas eles precisam assinar uma ata ou coisa do tipo. Essa analogia reflete o seguinte conceito:

- o cantor -> ‚Äúproducing code‚Äù == vai fazer algo que demora (asincrono)
- os f√£s -> consuming code‚Äù == v√£o pegar o resultado do ‚Äúproducing code‚Äù e fazer alguma coisa
- a ata -> √© a "Promise" que liga os dois c√≥digos

Promises s√£o objetos built-in do JS e noramlemente tem essa estrutura:

```js
let promise = new Promise(function (resolve, reject) {
  // colocamos nosso c√≥digo aqui (‚Äúproducing code‚Äù)
});
```

resolve e reject s√£o callbacks (fun√ß√µes) criados pelo JS.

- `resolve(value)` ‚Äî se o c√≥digo roda normalmente, vai retornar o "value"
- `reject(error)` ‚Äî se algum erro ocorre, "error" is the error object

Quando voc√™ cria uma "promise" usando new Promise, voc√™ tem "estados" e "resultados"
inicialmente o "state" √© pendente -> se tudo ocorre bem: "fulfilled" -> se n√£o: "rejected"
inicialmente o "result" √© undefined -> se tudo ocorre bem passa a ser o value de resolve(value) -> se n√£o, √© o erro de reject(error).
OBS: s√≥ pode existir um "resolve" ou um "reject" mas voc√™ pode escrever os dois sem problemas, desde que voc√™ fa√ßa uma condional.

```js
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve(alert("done")), 1000);
}
```

#### methods de propaga√ß√£o:

Voc√™ j√° tem a ata, e j√° produziu a musica, agora voc√™ s√≥ precisa enviar ela para os f√£s, mas como?
Usando um dos methods: .then, .catch, .finally
O ".then" √© o mais usado/universal. Voc√™ usa da seguinte forma:

```js
alert("inicio do c√≥digo");
let promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve("result"), 2000);
});
promise.finally(() => alert("Promise ready"));
promise.then((result) => alert(result)); // <-- .then handles the result
```

Vamos usar promises para reescrever o exemplo do carregamento de scripts, que usavam callbacks.

```js
function loadScript(src) {
  return new Promise(function (resolve, reject) {
    let script = document.createElement("script");
    script.src = src;
    //basicamente, podemos escrever as duas. Mas devemos fazer uma esp√©cie de condicional
    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error(`Script load error for ${src}`));

    document.head.append(script);
  });
}

let promise = loadScript(
  "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"
);

promise.then(
  (script) => alert("O script foi carregado"),
  (error) => alert(`O seguinte erro aconteceu: ${error.message}`)
);
promise.finally(() => alert("finaliza√ß√£o do processo"));
```

#### promise chaining:

Se voc√™ tem uma sequencia de processos ass√≠ncronos e quer interligar eles, com promises voc√™ faz isso de maneira simples. Basta chamar o ".then" dessa promessa. Repare que n√£o existe "espa√ßos" entre os .then. Eles est√£o: .then().then().then().then().then()

##### fetch example:

Normalmente promises s√£o usadas em network requests e voc√™ pode trabalhar com elas de diversas maneiras. Vamos ver um modo "vanilla" de lidar com o http request "fetch".
let promise = fetch(url); vai fazer uma request dada uma url e vai resolver(retornar) uma resposta incompleta (uma confirma√ß√£o de conex√£o) e depois uma completa (com os dados).

```js
//criando um user
let user = {
  name: "dFLPp",
};
//fazendo uma request ao github
fetch(`https://api.github.com/users/${user.name}`)
  // carregando a respose em .json
  .then((response) => response.json())
  .catch((err) => alert(err)) //opcional mas importante.
  // mostrando a imagem do perfil do user no github por 3s
  .then((githubUser) => {
    let img = document.createElement("img");
    img.src = githubUser.avatar_url;
    document.body.append(img);

    setTimeout(() => img.remove(), 3000);
  });
```

### Async/await:

√â um modo mais simples de se escrever promessas.
Usa-se a keyword `async` na frente de uma fun√ß√£o para dizer que ela Sempre retorna uma promessa. No exemplo a seguir percebe-se que a fun√ß√£o passa a ser ass√≠ncrona

```js
async function f() {
  return 1;
}
f().then(alert);
```

Usar async √© mais simples/menos confuso pois, como todas as fun√ß√µes declaradas com async retornam necess√°riamente uma promessa, podemos usar "return 1" ao inv√©s de return Promise.resolve(1);
Existe ainda a keyword "await". Ela s√≥ pode ser usada dentro de fun√ß√µes que s√£o "async" e ela faz o javaScript pausar a execu√ß√£o de algo at√© que a promessa returne algo.
N√£o √© obrigatorio, mas na maioria das vezes, voc√™ deve usar: "let a = await ..." ao inv√©s de usar "await ..." diretamente.

```js
async function f() {
  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("done!"), 1000);
  });
  let result = await promise; // a execu√ß√£o da fun√ß√£o Para aqui e s√≥ volta quando a promise retornar algo.
  alert(result); // "done!"
}
f();
```

Usando async/await vamos tentar reconstruir aquele exemplo de mostrar o icone do github de um user.

```js
let user = {
  name: "dFLPp",
};

async function showAvatar(name) {
  //faz a request
  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  //"traduz" a request em json us√°vel pelo c√≥digo
  let githubUser = await githubResponse.json();

  //mostra o √≠cone no html
  let img = document.createElement("img");
  img.src = githubUser.avatar_url;
  img.className = "promise-avatar-example";
  document.body.append(img);

  //espera 3s para apagar o icone
  await new Promise((resolve, reject) => setTimeout(resolve, 3000));
  img.remove();
  return githubUser;
}

showAvatar(user.name);
```

#### Error handling:

Quanto estamos trabalhando com async/await n√≥s estamos dentro de fun√ß√µes, ent√£o √© mais pr√°tico e f√°cil usar o try..catch ao inv√©s de usar o .catch (como acontecia em promises).

```js
async function f() {
  try {
    let response = await fetch("/no-user-here");
    let user = await response.json();
  } catch (err) {
    // catches errors both in fetch and response.json
    alert(err);
  }
}

f();
```

## Modules:

Modules s√£o arquivos que podem ser importados, permitindo usar c√≥digos em outros arquivos sem ter que entende-los ou reescreve-los
Ex: eu tenho dois arquivos no mesmo diret√≥rio: sayHi.js e main.js. Se eu quiser usar uma fun√ß√£o, ou uma vari√°vel, generators ou etc, eu preciso exportar ela (export)
J√° em "main.js" eu quero usar algo n√£o nativo, ent√£o eu preciso importar (import)

```js
// üìÅ sayHi.js
export function sayHi(user) {
  alert(`Hello, ${user}!`);
}

// üìÅ main.js
import { sayHi } from "./sayHi.js";
sayHi("John"); // Hello, John!
```

Existem alguns outros t√≥picos:

- `import *` vai importar todas as coisas que foram exportadas no arquivo alvo
- tanto no export quanto no import voc√™ pode utilizar "as" para se referir a uma fun√ß√£o ou coisa espec√≠fico.
- import deve estar no "top level" (n√£o pode estar fun√ß√µes, condicionais, blocos de c√≥digo no geral)

```js
// üìÅ say.js
export function sayHi() { ... }
export function sayBye() { ... }
export function becomeSilent() { ... }

// üìÅ main.js
import * as say from './say.js';

say.sayHi('John');
say.sayBye('John');
```

### Build tools:

Em projetos reais, normalmente n√£o se utilizam modules na sua vers√£o "Pura", uma ferramenta chamada de bundler vai organizar e otimizar os modules de modo que n√£o ocorram erros e que o app/site n√£o fique pessado.
Por exemplo, supondo que n√≥s utilizamos a bundler "Webpack", ao inv√©s de fazer v√°rios imports no html ou em outro .js, Nos podemos fazes esses v√°rios imports no arquivo especial do Webpack e ele ent√£o vai otimizar o c√≥digo.
Dessa forma ao inv√©s de fazer 5 imports no meu html, eu fa√ßo somente 1 (que √© o arquivo especial fornecido pelo bundler)

### Dynamic imports:

Tem sentido literal. O int√∫ito √© fazer o import de modules ou files de maneira "ao vivo" (on-demand), sendo necess√°rio usar o method "import()".
Na maioria das vezes, se voc√™ quer carregar um import em um momento espec√≠fico, √© poque voc√™ est√° usando async. Veja o exemplo que combina os dois conceitos:

```js
// üìÅ say.js
export function hi() {
alert(`Hello`);
}
export function bye() {
alert(`Bye`);
}
export default function() {
alert("Module loaded (export default)!");
}

// üìÅ index.html

<!doctype html>
<script>
  async function load() {		// s√≥ se pode usar await em fun√ß√£o async
    let say = await import('./say.js'); // voc√™ faz await no "import()";
    say.hi(); // Hello!
    say.bye(); // Bye!
    say.default(); // Module loaded (export default)!
  }
</script>

<button onclick="load()">Click me</button>

```

## Conclus√£o

Agora que voc√™ j√° sabe o b√°sico da sintaxe de javascript j√° pode come√ßar a integra-lo com HTML. Para isso √© s√≥ olhar as pr√≥ximas anota√ß√µes. Caso tenha d√∫vidas ou queira pesquisar mais sobre abaixo est√£o alguns links √∫teis:

- [MDN docs](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript)
- [Javascript info](https://javascript.info/)
