# Javacript: Introdução

## História:

Tudo é uma evolução/transformação, nada foi criado no zero. Com o surgimento do HTML e do HTTP, especialistas começaram a interagir e evoluir a ferramenta até que foi criada a Netscape, uma empresa importantíssima que financiou a criação do Live Script, uma linguagem scriptada que focava em dar "dinâmica" à pagina estática. Em função da popularidade da liguagem de programação Java, foi trocado o nome de Live Script para JavaScript (ambas são baseadas em "C", mas completamente diferentes). Para evitar copias e criar um padrão no mercado, a Netscape realizou uma parceria com a Ecma International e criou o EcmaScript, que é o JavaScript usado pelas pessoas atualmente. A versão mais atual do Javascript é a ES2022 (EcmaScript 2022).

O Javascript, no contexto histórico, foi criado para melhorar o HTML e na atualidade ainda é usado para tal, regulando o comportamento dos sites e fazendo uso do Unicode charset. Contudo, com a evoulação da linguagem ele passou a poder também ser usado fora dos web browsers, atuando no backend de server-side aplications. Existem ainda JavaScript Frameworks, eles são ambientes de devesenvolvimento que ajudam os developers a renderizar e criar coisas (eles facilitam a implementação de coisas ao fornecer uma "estrutura" própria).

No passado e ainda hoje utiliza-se Jquery. Jquery é uma library de JavaScript que foi feita para simplificar e otimizar a manipulação HTML DOM, além de ser capaz de fazer animações em CSS e receber e enviar informações de/para bancos de dados através do Ajax. OBS: DOM = Document Object Mode. Ele permite que você trabalhe diretamente com os elementos do html (div, h3, span, etc) sem precisar "converter" ou ter trabalho a mais em JavaScript.

Atualmente exitem ferramentas/frameworks que são muito melhores que Jquery (como Angular, React, Svelte), todos eles facilitando a modificação e implementação de código em websites. As principais features de um framework são: Rendering, Data handling e Event handling. Aliás, enquanto python usa a "Snake case" (abacate_bonito), JavaScript usa a "Pascal case" (abacateBonito ou AbacateBonito)

## Aprendizado:

O trabalhoso não é entender a sintaxe, é desenvolver o pensamento criativo de como resolver um problema real com essa sintaxe.
Você deve desenvolver a capidade de transformar um texto/pedido em instruções, como se fossem uma recita. Depois basta "seguir" essa recita na linguagem de programação e faze com que cada passo se conecte com o anterior.

## "use strict":

É uma string que você sempre deve escrever na liha 1 do seu arquivo .js. Basicamente é responsável por "ativar" funcionalidades modernas do javaScript.

## Erros:

Javacript é uma linguagem interpretada. Isso significa que, em troca de ter uma sintaxe mais agradável e flexivel ele vai ter uma performance inferior. Em se tratando dos erros que você encontrar quando escrevendo em javascript os principais são:

- **syntax errors**: você escreveu errado e/ou não seguiu a "ortografia" da linguagem.
- **Logical errors**: você emplementou o código em uma logica fundamentalmente errada. O compilador/interpretador vai funcionar mas não do jeito que deveria.

## Operators:

São simbolos que você pode utilizar para fazer a interação entre duas variáveis. Existem os operadores matemáticos (que servem para somar, subtrair, etc), os lógicos (Que servem para comparar duas variáveis) entre outros. Alguns operadores comuns são encontrados abaixo:

- `!=` (diferente)
- `**` (pontenciação)
- `%` (resto da divisão)

- `>=` (maior ou igual)
- `<=` (menor ou igual)
- `==` (igual lógico)
- `===` (estritamente igual. Também lógico)

- `x += 5` é o mesmo que `x = x + 5`
- `x /= 5` é o mesmo que `x = x / 5`
- entre outros

## Variables:

### declaração:

A nossa básica é: Variables são "containers" para values. Variables (e objects) Não são seu values, são "espaços" onde eles estão armazenados.
Existem 3 formas de declarar uma variável (criar uma "caixa" vazia que armazena os valores que você quer):

- `var`: Modo antigo. É confuso mas tem suas vantagens (ex: hoisting e multiplas declarações para uma mesma variável).

  ```js
  var count = 1;
  var count = 2; //É permitido
  ```

- `let`: Modo "novo". Faz o mesmo que o var mas não tem hoisting nem é permitido fazer multiplas declarações para uma mesma variável.

  ```js
  let count = 1;
  let count = 2; // É proibido
  count = 2; // É permitido
  ```

- `const`: Cria a variável do mesmo jeito, mas o value/valor atrelado à ela não poderá variar. É recomendado usar quando os dados são "estáticos" (tipo um botão).

  ```js
  const count = 1;
  count = 2; // É proibido
  ```

Como regra geral, sempre declare variáveis como `const` a menos que você saiba que elas vão mudar, nesse caso use `let`.

### Escopos de declaração:

Em JS existem três scopes:

- **Global Scope** (a variável pode ser usada em todo o código)
- **Function Scope** (a variável só é usada dentro de funções)
- **Block Scope** (variáveis criadas dentro de "{ chaves }" (block) não podem ser acessadas fora dessa block. Cada bloco é único e não precisa de indentificação)

### Data Types:

#### Number:

Esse Data Type é igual ao "float" do python, com 64 bits de comprimento. Os valores em notação científica também são do datatype "number". Ex: `const number3 = 3e5 // 3* 10^5`

#### String:

Em JS as aspas normais ('') e as duplas ("") são tratadas como iguais sendo usadas para declarar strings.
As aspas "reversas" (\`\`) são usadas para fazer **template strings** (template Literals). Ex: let x = \`Posso usar o valor dessa ${variavel}\`;

#### Boolean:

Só exitem dois valores possíveis, true ou false. Normalmente usada em alguma expressão com operadores logicos.

#### Symbol:

É um valor único que você obtem através de uma string. Você não pode ver o valor/conteúdo de uma symbol, é como se fosse um uid.
Dois symbols de uma mesma string não são iguais. O objetivo dos symbols é tratar dados de maneira mais discreta (privacidade) mas não são "fortes" o suficiente para tal, sendo necessário usar proxies e outras tecnologias em um app profissional.

#### Objects:

Objects armazenam os dados em key/value pairs. As keys tem que ser strings e os values podem ser qualquer outros data type (até mesmo outros objects ou alguma função. São criados ao usar chaves ({}).

```js
let object = {
  key1: "value",
  key2: 5,
};
```

#### Undefined:

É a variable global que representa a não existênicia de dados. Quando você faz `let x;` Você está dizendo que x existe, mas não está dando um valor para ele.
Até que um valor seja atribuido à x ele será reconhecido como "undefined". A keyword `void` pode ser usada para ignorar o output associado a uma expressão e então retornar "undefined". A sintaxe é `void <expression>`.

```js
function f() {
  document.body.style.backgroundColor = "red";
  document.body.style.color = "white";
} //a função é totalmente funcional
let vari = undefined === void f(); //Como "void f()" é undefined então vari = true
alert(vari);
```

#### Null:

Normalmente é usada para indicar falta de "indentidade", ou então quando uma variável vai ter um valor no futuro, mas não tem agora. Por exemplo `let x = null;`

### Hoisting:

Hoisting se refere ao processo, realizado pelo interpretador da linguagem, de mover as Declarações de funções, variáveis e classes para o topo de seus respectivos escopos, antes de serem executados.

#### Em funções:

```js
//O "correto" seria escrever a função primeiro e depois "chamar" ela, mas:

catName("Tiger");

function catName(name) {
  console.log("My cat's name is " + name);
}
//O código acima roda, mesmo que a função seja chamada antes de ter sido declarada. Output: "My cat's name is Tiger"
```

#### Em variáveis:

Basciamente só quando você declara variáveis com o "var" que o hoisting é possível, porém diferente do modo que acontece com as funções.

```js
console.log(num);
/* Vai retornar 'undefined' (e não 6), porque o hoisting feito pelo var é de "declaração", ou seja, ele só declara a variável "num"
    (e como não atribui um valor a ela, ela fica como undefined) */
var num = 6; // Initialization and declaration.
console.log(num); // vai retornar/printar 6 pois é executada depois da linha de declaração e Atribuição.
```

## Condicionais:

No JS clássico existem 2 modos de fazer condicioais

1. If..Else

```js
if (choice === 'sunny' && temperature < 86) { //após o if, entre paranteses está a condição. Se ela for verdadeira o bloco de código é executado
//OBS: && = AND e || = OR
//some code
} else if (choice === 'sunny' && temperature >= 86) { //else if, você já sabe como funciona
//other code
} else {
break;
}
```

2. Switch..Case

```js
let variavel = 50;
switch (typeof variavel) {
  case "number":
    alert("1");
    break;
  case "string":
    alert("2");
    break;
  default:
    //default code
    break;
}
```

3. Operador ternário

```js
let a = "Abacte";
let b = a === "Coxinha" ? "yes" : "no";
```

## Loops/Laços:

1. For

```js
for (let i = 0; i < 5; i++) {
  console.log("ABACATE");
}
```

2. While

```js
let i = 0;
while (i < 5) {
  console.log("ABACATE");
  i++;
}
```

3. Do..While

```js
let i = 0;
do {
  console.log("ABACATE");
  i++;
} while (i < 5);
```

- 4. For..In (iteração dentro de uma coleção/objeto)

```js
const a = {
  type: "a",
  id: 5031,
};
for (let key in a) {
  console.log(a.id);
  //vai dar o resultado duas vezes porque tem 2 keys
}
```

- 5. For..of (iteração dentro de arrays)

```js
const cores = ["abacate", "2"];
for (let cor of cores) {
  console.log(cor);
}
```

## Functions:

São blocos de código indentados (dentro de chaves {}) e que só são executadas quando são invocadas (algum outro comando ou evento a executa) ou quanto se auto-invocam (executam "automaticamente"). Você deve criar funções/blocos de códigos auto contidos para seus propósitos (não crie funções muito grandes ou que acessam muitas coisas, dê prioridade à criar outra funções).

```js
function convertToFahrenheit(celsius)
{
return ((9/5) \* celsius) + 32
let variable = "abacate" === "coxinha" //A função vai ignorar essa linha pois ela esta depois do "return" e no mesmo bloco (de codigo), ou seja, vai ser pulada/ignorada.
}
alert(convertToFahrenheit(5))
alert(variable) //como "variable" não foi atrubida, nada acontece.
```

### Arrow functions:

É uma notação mais consisa que visa compactar a declaração de funções. Outro detalhe é que arrow functions não tem um "this." próprio, isso significa que a função não consegue entender/encontrar o "contexto" em que está. Graças a essa funcionalidade arrow functions são normalmente usada para declarar funções de callback (que são passadas para outras funções como parâmetro para serem executadas no final da execução da primeira).

```js
const array = [
  { id: 1, name: "a" },
  { id: 2, name: "b" },
];
console.log(
  array.find((array) => {
    return array.name === "a";
  })
);
```

### Rest parameters:

O símobolo `...` pode ser tanto **rest paramenter** quanto **spread operator**, dependendo do contexto.

É **rest parameter** quando você o usa como argumento. Basicamente é utilizado para passar argumentos "infinitos" para uma função.

```js
function sumAll(...args) {
  // args is the name for the array
  let sum = 0;
  for (let arg of args) {
    sum += arg;
  }
  return sum;
}
alert(sumAll(1)); // 1
alert(sumAll(1, 2)); // 3
alert(sumAll(1, 2, 3)); // 6 ##
```

É **spread operator** quando você usar ele na atribuição de coisas. Basicamente serve para copiar/concatenar/manipular objects e arrays.

```js
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];
let merged = [0, ...arr, 2, ...arr2];
alert(merged); // 0,3,5,1,2,8,9,15
```

### Callbacks:

Callback é um termo utilizado normalmente quando se trabalha com async/await, mas, basicamente, consiste em chamar um função dentro de outra função, criando uma relação de dependencia/sequencia lógica de eventos.

```js
function preProducao(arg1, iniciar_producao) {
  if (arg1 === "iniciar") {
    iniciar_producao();
  }
}

function initProducao() {
  alert("doing something");
}

preProducao("iniciar", initProducao);

//repare que a função que inicia a produção só começa/ocorre quando a função "preProducao" da a liberdade/ordem de iniciar.
```

### Recursion and stack:

Recursividade é um programming pattern usado para deixar o código mais limpo ou fazer algo mais simples de intender. Consiste basicamente em, dentro de uma função, chamar a própria função. Vejamos dois modos diferentes de criar uma mesma função:

```js
//Com o for loop
function pow(x, n) {
  let result = 1;
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  return result;
}
```

```js
//Com recursividade
function pow(x, n) {
  if (n == 1) return x;
  else return x * pow(x, n - 1);
}
```

Mais detalhadamente, quando uma função é executada, as informações dela (como o valor de this ou de outras variáveis) são armazenadas em uma data structure especial chamada de **execution context**.
Quando uma função é chamada dentro de outra função (caso da recursividade), o execution context mais externo é pausado e um novo é criado. Essa dinâmica de "pausar" e criar outro em cima funciona na base de stacks (pilhas).
Basta perceber que o primeiro execution context vai ser o ultimo a ser retornado pois todos os outros que vieram depois dele precisam ser "retirados" antes de modo que o mais externo possa voltar a ser executado.
Como criar execution contexts demanda memória, você não pode se dar ao luxo de fazer isso várias vezes. No caso da função "pow" vão ser criadas "n" execution contexts.
Todas as funções recursivas podem ser reescritas como loops, e loops consumem/precisam de menos memória. Entretando contruir um loop complexo é uma tarefa mais difícil.

### Scheduling:

funções que permitem que outras funções rodem depois de um certo tempo. Serve para simular uma "chamada assincrona".

- setTimeout: permite rodar uma função depois de um certo tempo.

```js
function sayHi() {
  alert("Hello");
}

setTimeout(sayHi, 1000);
//1000ms = 1 segundo
```

- setInterval: permite rodar uma função dado um periodo, se repetindo regularmente.

```js
let timerId = setInterval(() => alert("tick"), 2000);
//vai rodar a cada 2 segundos. Além disso é infinito, ou seja, não vai parar.
// Temos que parar "manualmente" usando o setTimeout e clearInterval.
setTimeout(() => {
  clearInterval(timerId);
  alert("stop");
}, 5000);
```

### Function biding:

Basicamente, quando queremos passar uma key/value de um objeto em uma função(callback) e esse key/value usa o "this", o "contexto" do "this" é perdido.
Em outras palavras, a função que recebe um objeto como argumento não faz a minima ideia sobre o que "this" é.
Para resolver isso podemos usar um wrapper, ou seja, criar uma "lambda function" que salva o "contexto" do this e então passa ele para a outra função. Esse metodo tem vulnerabilidades, sendo recomendado usar o method bind.

O method bind basicamente vai pegar uma função, "juntar" o seu contexto(objeto ou qualquer outra coisa que o .this se refere) e então criar um objeto especial que pode ser chamado(callback) como uma função.

```js
function hash(arguments) {
  return arguments[0] + "," + arguments[1];
}

//decorator
function cachingDecorator(func, hash) {
  let cache = new Map();
  return function () {
    let key = hash(arguments);
    if (cache.has(key)) return cache.get(key);
    else {
      let result = func.call(this, ...arguments);
      cache.set(key, result);
      return result;
    }
  };
}

//objeto com o método que ser quer fazer o cache
let worker = {
  slow(min, max) {
    console.log("Working...");
    return min + max;
  },
};

worker.slow = cachingDecorator(worker.slow, hash);
let start = new Date();
worker.slow(3, 5);
let end = new Date();
console.log(`Demora: ${end - start}ms`);

start = new Date();
worker.slow(3, 5);
end = new Date();
console.log(`Demora (cached): ${end - start}ms`);
```

Esse exemplo é um pouco mais complexo. Se tiver dificuldade de entender o porque da utilização da função hash(), dê uma olhada [aqui](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments).

## Objects:

A analogia é perfeita: Um carro é um objeto.

- Todos os carros tem as mesmas properties (cor, tamanho, peso) mas seus values são diferentes
- Todos os carros tem os mesmos methods (ligar, freiar, etc) mas eles são acionados em momentos diferentes.

É uma boa prática usar a keyword "const" para definir/declarar um objeto, porém objetos em JS são especiais por serem dinâmicos (podem ser alterados) e portanto isso fica a critério próprio. Você pode declarar/criar um objeto de duas formas:

```js
let user = new Object(); // "object constructor" syntax
let user = {}; // "object literal" syntax
```

Você pode acessar o valor de uma propertie de duas formas:

- objectName.propertyName (ex: car.color)
- objectName["propertyName"] (ex: car["type"])

Methods são as funções/ações que aquele objeto possue/cotem e portanto pode executar. Basta criar/declacar o value de uma key como uma function:

```js
const person = {
  firstName: "John",
  lastName: "Doe",
  id: 5566,
  fullName: function () {
    return this.firstName + " " + this.lastName; // repare na indentação
  },
};
```

### Computed properties:

Você pode dar o nome de uma key de forma dinâmica (mais não pode acessar esse nome de forma dinâmica).

```js
let fruit = prompt("Which fruit to buy?", "apple");
let bag = {
  [fruit]: 5, // o nome da key é o valor da variável "fruit"
};
alert(bag.apple); // Porém para fazer o alert nos precisamos saber e especificar qual o nome da key ("bag.[fruit]" não funciona).
```

### Criando objetos dinamicos com "this":

Você pode usar a keyword `this` dentro de um method de modo a receber um valor do prompt. Depois de chamar esse método, você pode armazenar esse valor "dinamicamente" como um value. Dentro de um objeto.

```js
let person = {
  name: this.name,
  age: this.age,
  email: this.email,
  readData() {
    this.name = +prompt("Diga seu nome");
    this.age = +prompt("Diga sua idade");
    this.email = +prompt("Diga seu email");
  },
};
person.readData(); //vai fazer os prompts e pegar os dados

if (person.age < 18) {
  alert(`Olá ${person.name}, infelizmente você não pode entrar =(`);
} else {
  alert("ABACATE");
}
```

### “for…in” loop:

Basicamente você pode iterar dentro de um objeto/array. No caso dos objetos é importante prestar atenção na sintaxe para diferenciar as keys dos values:

```js
let user = {
  name: "John",
  age: 30,
  isAdmin: true,
};

for (let key in user) {
  // keys
  alert(key); // name, age, isAdmin
  // values for the keys
  alert(user[key]); // John, 30, true
}
```

### Copiando objetos:

Basciamente se você tem um objeto e você cria outra variável e iguala ele a esse objeto, você não está fazendo uma cópia independente, está criando uma nova referencia para o objeto. Para efetivamente clonar um objeto pode-se usar o method "Objct.assign":

```js
const oldObj = { abacate: 1, sim: false };
const newObj = Object.assign({}, oldObj); //{} significa que copia todo o objeto.
console.log(oldObj);
console.log(newObj);
```

### Object.keys, values, entries:

Como objects são bastante flexiveis e podem se tornar complexos, existe uma "entidade" chamada de Object que se refere a estrutura do objeto.

- Object.keys(obj) retorna uma array com as keys.
- Object.values(obj) retorna uma array com os values.
- Object.entries(obj) retorna o key/value pair em forma de array.

E como o resultado desses methods são arrays, você pode fazer uma iteração sobre eles.

### Object destructuring:

Consiste em "desmantelar" partes de um objeto e atribuir a novas variáveis:

```js
let options = {
  size: {
    width: 100,
    height: 200,
  },
  items: ["Cake", "Donut"],
  extra: true,
};

let {
  size: { width, height },
  items: [item1, item2],
  title = "Menu", // campo não presente no objeto (recebe valor atribuido)
} = options; //repare que options é nome do objeto base

alert(title); // Menu
alert(width); // 100
alert(height); // 200
alert(item1); // Cake
alert(item2); // Donut
```

### Factory function:

É uma função que cria um objeto.

```js
function abc(prop1, prop2, prop3) {
  return {
    keyUm: prop1,
    keyDois: prop2,
    keyTres: prop3,
  };
}
const obj1 = abc(1, 2, 3);
console.log(obj1);
```

### Constructor Functions:

Também é utilizada para criar objetos, porém ela é como se fosse um "classe" do python (um blueprint para objetos). Utiliza o "new" para criar um elemento dessa "classe".
Normalmente constructor functions começam com letra maiúsculas para se diferenciar. Repare que, enquanto as factory functions usam "return" para se referir aos seus parâmetros, uma constructor function utiliza o "this." para se referir ao seus parâmetros.

```js
function objMaker(prop1, prop2, prop3) {
  this.keyUm = prop1;
  this.keyDois = prop2;
  this.keyTres = prop3;
  this.methodUm = function () {
    console.log("methodUm");
  };
}

const obj1 = new objMaker("Abacate", "ABACATE", "a b a c a t e");
console.log(obj1);
```

### OOP:

Quando você usa objetos para representar entidades(funções, uma parte da memória, etc) você está realizando/fazendo: object-oriented programming.
Essa abordagem é versátil e amplamente utilizada por programadores. É como se fosse "o jeito de certo de calçar um sapato".
Você pode calçar de diferentes formas, mas noramlmente você vai querer/preferir calçar do "jeito certo".
Isso é tão verdade que foi daí que o conceito de Design patterns foi criado. Isso basicamente se refere a um conjunto de estratégias/modos de resolver problemas comuns/recorrentes usando OOP.

### Chaining:

É quando você faz `obj.prop1.prop2.method1.method2`, tipo, você vai fazendo vários `.algumaCoisa` seguidos. Isso pode ser útil em algumas situações.
Por exemplo, existem situações onde vamos precisar usar o número da casa de um usuário através de: `user.adress.street.number`. Reparem que tem 4 properties aí.
Basciamente para que você possa usar chaining você deve rotornar o próprio objeto (e deixar para fazer o output separadamente), de modo que o próximo `.algumaCoisa` vai se referir ao objeto recem alterado. Usa-se `return this`;

#### Optional chaning:

As vezes, alguams informações são opcionais, de modo a não existencia delas faz o código parar por causa do erro. É melhor retornar undefined que parar todo o programa.
Tipo, no exemplo anterior, pode ser que o user tenha dado o número da casa dele, mas não tenha dado a rua, isso vai gerar um erro que vai parar todo o código. Não queremos isso.
Para evitar o erro, e retornar `Undefined`, precisamos usar o operador `?.`. Ele SÓ DEVE ser usado quanto uma property possa ser nula.
Ex: `user.adress.street?.number`. Dessa forma, a obtenção de `street` vai ser opcional, de modo que se ELE não existir, o código simplismente retorna undefined.
Repare que é só ele. Se user, adress ou number não existirem, o código vai dar erro de qualquer jeito. Então, o que fazer? Usar `?.` nos elementos certos e fazer um código limpo.
O elemento que está antes(a esquerda) do `?.` deve existir/ser declarado, so não precisa ter um valor. O `?.` não pode ser usado para ler valores, tipo, deixar a entrada de um parâmetro como opcional. Essa funcionalidade existem em frameworks e no JS através de outras formas.

### JSON:

JavaScript Object Notation foi criada, como o nome ja diz, para se transmitir o conteúdo de objetos do javaScript através da internet(HTTP). Com o passar to tempo a formatação se formou padrão para transmissão de dados na internet e é usada em outras linguagens.
No javaScript, JSON basicamente é a conversão de um objeto para uma string, com uma formatação especial. Para fazer essa conversão usamos JSON.stringify(obj);
Esse method ignora certas properties, como methods, symbolic keys/values e o null.

```js
let student = {
  name: "John",
  age: 30,
  isAdmin: false,
  courses: ["html", "css", "js"],
  wife: null,
};

let json = JSON.stringify(student);

alert(typeof json); // we've got a string!

alert(json);
```

Para fazer o caminho inverso (JSON -> object "nativo") usamos: JSON.parse.

```js
let userData =
  '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';
let user = JSON.parse(userData);
alert(user.friends[1]); // 1
```

### Garbage collection:

Diferente da linguagem C, onde a a memória deve ser monitorada e controlada cautelosamente, o javaScript possue um algorítimo interno que realiza limpeza de memória de modo a "deletar" partes do código que são/ficam inúteis.
Em JS objetos(quase tudo) são mantidos na memória enquanto eles são "alcançaveis" pelo "root" do JS, que é chamado de `<global>`.
Ou seja, se você diz que algo é null e ele não é percebido pelo `<global>` (não é passado como argumento, não serve de base para uma variável, etc), então ele será deletado.
E, analogamente, se algo é usado definido como null, é passado como parâmetro E tem conexação com o `<global>` então ele não será deletado.
Importante notar a utilização do "E" na ultima linha pois, não basta que o objeto esteja ligado à outro, ele TAMBÉM precisa estar ligado até o `<global>`, otherwise ele e os outros objetos que estão ligados à ele seriam "Unreachable islands"

## Prototypes & inheritance:

É um modo/metodo em programação no geral que permite estender funcionalidades/objetos existentes.
Imagine que você tem um objeto chamado de user e que você quer criar outros 2: admin e guest. Independente de como você vai criar esses objetos ambos vão ser users, concorda?
Dessa forma podemos usar o objeto user que já existe e estender ele de modo a reusar algumas partes dele e implementar outras partes dentro de cada objeto.

### Prototype (proto):

Em JS existe um propriedade escondida dos objetos chamada de `[[Prototype]]` que aponta para "null" ou para outro objeto.
Basicamente quando você cria um objeto, `[[Prototype]]` é como se fosse o DNA herdado do objeto. Como, naturalmente objetos não herdam caracteristicas de outros objetos, logo `[[Prototype]` é naturalmente null.
Para mudar o valor de `[[Prototype]]` e fazer ele apontar para outro objeto, podemos usar o **proto**. Vamos usar ele nesses exemplos iniciais, porém ele está em desuso

```js
//objeto "inicial"/acestral
let animal = {
  eats: true,
  walk() {
    alert("Animal walk");
  }
};

//objeto "descendente". Queremos que ele herde as properties de "animal"
let rabbit = {
  jumps: true,
  **proto**: animal //basta passar um link/DNA do objeto "animal" e agora o obj "rabbit" também possue essas properties
};

//Outro objeto. Uma espécie de coelho. Ele é claramente um coelho E um animal
let longEar = {
  earLength: 10,
  **proto**: rabbit //como rabbits já tem o "DNA" de um animal, basta ter o DNA do "rabbit"
};

longEar.walk(); //Naturalmente não tem property "walk", é pega do obj "animal"
alert(longEar.jumps); //Naturalmente não tem property "jump", é pega do obj "rabbit"
```

### F.prototype:

Você também pode herdar properties sem usar o **proto**. Basta usar a "new" sintax e usar o method ".prototype"

```js
//obj "original"/ancestral
let animal = {
  eats: true,
};

//constructor function.
function Rabbit(name) {
  this.name = name;
}

//dizendo que os objs criados apartir constructor function "rabbit" são descendentes de "animal"
Rabbit.prototype = animal;

let rabbit = new Rabbit("White Rabbit"); //criando um objeto "diferenciado"
alert(rabbit.eats); // true
```

### Substitutos do **proto**:

Como citado, o **proto** está em desuso e existem métodos mais modernos de se definir o prototype de um objeto:

- `Object.create(ancestral, [descriptors])` cria um obj vazio com o prototype do obj "ancestral"
- `Object.getPrototypeOf(obj)` retorna o `[[Prototype]]` do obj.
- `Object.setPrototypeOf(obj, ancestral)` atribui o `[[Prototype]]` do obj ao do "ancestral".

```js
//obj "acestral"
let animal = {
  eats: true,
};

// criando um novo obj, vazio, como mesmo DNA/properties que "animal"
let rabbit = Object.create(animal);
//repare na utilização da "entidade" "Object".

alert(rabbit.eats); // true
alert(Object.getPrototypeOf(rabbit) === animal); // true
Object.setPrototypeOf(rabbit, {});
```

## Classes:

### sintaxe e conceitos básicos

Classes são um conceito utilzado em OOP que serve para criar objetos padronizados/com um conjunto inicial de dados semelhantes. O objetivo das classes é focar mais na utilização dos methods. Uma observação importante é que: você não deve colocar virgulas para separar os methods. O method fundamental das classes é o "constructor". É dentro dele que você coloca as "key/values" que o objeto vai ter.

```js
class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    alert(this.name);
  }
}

let user = new User("John");
user.sayHi();
```

Classes são uma maneira mais simples e versátil de se usar constructor functions (que já foram citadas no caṕitulo sobre objetos). Na realidada, uma classe é uma constructor function que possue um prototype. Dentro de uma classe você também pode criar key/values diretamente, mas isso é "restritivo" uma vez que esse mesmo valor de se repete para todos os objetos.

#### static properties:

São properties que não são de um objeto, mas sim a toda a classe. Pode-se dizer que são properties que todos os objetos tem porque a própria classe o tem. Para criar ele dentro da classe, você usa a keyword `static`.

#### getters/setters:

**getter**: é um method que usa da keyword `get` para retornar/mostrar um valor de objeto/classe de forma dinâmica. Ou seja, de um valor que ainda não foi definido.
As funções criadas com o get não podem ter nenhum parâmetro.

**setter**: é um method que usa a keyword `set` e serve para criar/alterar um valor dentro de um objeto/classe.
As funções criadas com o set só podem ter exatamente 1 parâmetro.

Só deixando claro, get e set são keywords que servem para criar funções com propósitos específicos.

```js
class Aluno {
  // usando um constructor para definir as key/values iniciais.
  constructor(nome, curso, semestre) {
    (this.nome = nome), (this.curso = curso), (this.semestre = semestre);
  }
  // criando um method para retornar o nome do aluno antes mesmo dele ser definido
  get nomeAluno() {
    return this.nome;
  }
  //criando um nome para o aluno se ele não existir e alterando se existir
  set nomeAluno(nomeAluno) {
    this.nome = nomeAluno;
  }
}

let lucas = new Aluno("", "Engenharia", 5);
lucas.nomeAluno = "Lucas";
console.log(lucas.nome); //Lucas
lucas.nomeAluno = "Abacate";
console.log(lucas.nomeAluno); // "Abacate" usando getter
```

### Class inheritance

Lembra do que falamos sobre prototypes? Vamos usar isso aqui. Basicamente para fazer uma classe herdar methods e properties de outra classe basta você usar a keyword "extends".

```js
//classe normal
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name} runs with speed ${this.speed}.`);
  }
}
//criação de uma classe que herda coisas de "Animal"
class Rabbit extends Animal {
  hide() {
    alert(`${this.name} hides!`);
  }
}

let rabbit = new Rabbit("White Rabbit");
rabbit.run(5); // White Rabbit runs with speed 5.
rabbit.hide(); // White Rabbit hides!
```

Entrentanto as coisas não são tão simples. Repare que essa classe "Rabbit" não possue um constructor. E se possuisse? Bom, ocorreria um conflito do "this".
Basicamente você precisa saber de 3 coisas:

1. quando você criar cria uma classe sem constructor, ele existe, mas está vazio.
2. a classe que herdou coisas sempre vai dar prioridade a seus proprios elementos, só depois usando os herdados (caso tenham o mesmo nome)
3. Para que "o que herdou" se refira a seu ancestral utiliza-se o method super(). Dessa forma, se a classe ancestral e a descendente possuem o mesmo nome em suas properties, e você que usar a do ancestral, deve usar "super(prop)";

```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
}

class Rabbit extends Animal {
  constructor(name, earLength) {
    super(name); //vai usar o constructor ancestral para criar o nome
    this.earLength = earLength; // property especifica dessa classe
  }
}

let rabbit = new Rabbit("White Rabbit", 10);
alert(rabbit.name); // White Rabbit
alert(rabbit.earLength); // 10
```

### Private/protected

É algo fundamental quando você está criando coisas complexas/ que usam ou se comunicam, protengendo elas de serem alteradas.
Uma analogia seria com uma cafeteira. Ela é um objeto complexo, tranforma a corrente alternada em corrente contínua e depois tranforma em calor e etc.
Entretanto, para o usuário isso não importa, o que importa é que ele coloca água em um lugar, pó em outro e então aperta um botão.
Esse é o tipo de proteção/abstração.

- Internal interface – methods and properties, accessible from other methods of the class, but not from the outside.
- External interface – methods and properties, accessible also from outside the class.

Para fazer essa proteção não existe um method ou função especifica. Basicamente você tem que usar seu conhecimento para tal.
Usar condicionais para controlar o valor de algo, usar um get e não usar um set para tornar a property read-only. Etc;
Na realidade, não há necessidade de usar set/get, desde que você tenha um controle maior no momento de criar a função.
OBS: é uma convenção usar `*` no nome de properties protegidas;

```js
class CoffeeMachine {
  *waterAmount = 0;
  set waterAmount(value) {
    if (value < 0) {
      value = 0;
    }
    this.*waterAmount = value;
  }

  get waterAmount() {
    return this.*waterAmount;
  }

  constructor(power) {
    this.*power = power;
  }

  get power(){
    return this.*power;
  }

}

// create the coffee machine
let cafeteira = new CoffeeMachine(100);

cafeteira.waterAmount = -10;
alert(cafeteira.waterAmount)
cafeteira.waterAmount = 23;
alert(cafeteira.waterAmount)
alert(cafeteira.power);
cafeteira.power = 200;
alert(cafeteira.power);
```

## Error handling:

É impossivel fazer codigo sem erro. O intuito de cuidar dos erros e passar um auxilio personalizado ao usuário e impedir que todo o script morra.
Como já dito, se um erro ocorre Todo o script/codigo para. Isso é ruim. Nós queremos fazer com que o código continue apesar dos erros. Para isso podemos utilizar o "try...catch"

### try...catch:

É uma especie de condicional que funciona sincronamente, para cuidar de erros.

```js
try {
  //code to run
  alert("Start of try runs");
  alert("End of try runs");
} catch (err) {
  //error handling
  alert('This "Catch" will be ignored if there is no errors');
}
```

O argumento "err" pode ter qualquer nome. Ele na realidade representa um objeto que vai possuir informações sobre o erro.
Existem alguns methods que podemos usar nesse objeto:

- `err.name; // Error name`
- `err.message; // Textual message about error details.`

Nós também podemos criar pontos de verificação e se o código não passar neles podemos "jogar" um erro usando throw. Normalmente você também precisa criar um error objet ao usar o "Error", "SyntaxError" ou etc

```js
let json = '{ "age": 30 }';
try{
let user = JSON.parse(json);
if(!user.name){
throw new SyntaxError("Dados incompletos. Nome não disponível");
}
alert("user.name); //só vai ser executado se o throw não ocorrer. Ele é como se fosse um return.
} catch(err){
alert("O seguinte erro ocorreu: " + err.message);
}
```

### finally:

Assim como em python, também existe a keyword "finally". Ela vai ser executada tamnto depois do try quanto depois do catch.
OBS: Existe um built-in error object chamado de "Error"
OBS: Como erros são objetos com informações, você pode criar e estender respostas para certos tipos de erro. Tendo cuidado quando for usar a property "name", não esquecendo de usar o "super()".

## Promises, async/await

### Callbacks:

No mundo real as coisas não ocorrem imediatamente. Por exemplo, se seu computador é lento e você quer fehcar o google e abrir um jogo, o jogo não vai esperar o google fechar para poder abrir.
Podemos dizer que a atividade de fechar o google não ocorre imediatamente, e o jogo não espera ela acontecer.
Vamos trazer isso para o javaScript:

```js
//função que vai criar um tag <script> no html, dado o path até a .js file
function loadScript(src) {
  let script = document.createElement("script");
  script.src = src; //src é uma property do elemento script, que é representado pela variável script
  document.head.append(script);
  //inicando o carregamento do script com esse path
  loadScript("/my/script.js");
  //dentro desse script existe uma função chamada de func123();
  func123(); //gera uma erro, pois o carregamento não ocorre automaticamente
}
```

Para executar a função desse script no exato momento em que ele carregar precisamos de um callback, uma afirmação que diz: "pronto, já pode rodar".
Para criar/gerar uma calback você precisa:

1. Na função que precisa do callback(loadScript) adicinar outro parâmetro, que será o callback
2. usar o ".onload" method para rodar o calback, usando a keyword "callback()"
3. Quando chamar a função, detalhar como a callbakc funcionará:
   ```js
   //modificando a função para que ela possa usar um callback
   function loadScript(src, callback) {
    let script = document.createElement('script');
    script.src = src;
    script.onload = () => callback(script);
    //quando o script carregar, você vai rodar a função chamada de callback e passar esse próprio script como argumento
    script.onerror = () => callback(new Error("Ocorreu um erro durante o carregamento do script"));
    document.head.append(script);
   }
   //Criando manualmente a callback dessa função. Quando o script carregar essa função vai rodar.
   function callback(script){
    alert(`Cool, the script ${script.src} is loaded`);
    alert( * ); // function declared in the loaded script
   }
   loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', callback);
   ```

Normalmente você não precisa criar uma função separada chamada callback, sendo uma arrow function anonima.
A ideia de callback é: eu vou executar isso necessariamente depois disso. Em uma espécie de ordem/cadeia.

Entretanto existe um problema com esse código, ele não tem controle sobre erros. Veja uma maneira mais consisa e "correta":

```js
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  //A função callback vai ter dois parametros agora. O primeiro é um erro e o segundo o script
  //Se o script conseguir carregar, o primeiro argumento é nulo e tudo ocorre naturalmente
  script.onload = () => callback(null, script);
  //se o ocorrer erro, só vamos passar o primeir argumento, e ele vai ser um erro.
  script.onerror = () => callback(new Error());
  document.head.append(script);
}
// aqui passamos a função callback como uma arrow anonymous function.
//repare que passamos dois argumentos (o erro, o script).
loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', (error, script) => {
if(error){
  alert("Deu pepino");
}else{
  alert(`Cool, the script ${script.src} is loaded`);
  alert( * ); // function declared in the loaded script
}
});

```

### Promises:

Imagine que você é um cantor e seus fãs enchem seu saco por música novas. Daí você promete pra eles que você vai mandar assim que estiver pronto, mas eles precisam assinar uma ata ou coisa do tipo. Essa analogia reflete o seguinte conceito:

- o cantor -> “producing code” == vai fazer algo que demora (asincrono)
- os fãs -> consuming code” == vão pegar o resultado do “producing code” e fazer alguma coisa
- a ata -> é a "Promise" que liga os dois códigos

Promises são objetos built-in do JS e noramlemente tem essa estrutura:

```js
let promise = new Promise(function (resolve, reject) {
  // colocamos nosso código aqui (“producing code”)
});
```

resolve e reject são callbacks (funções) criados pelo JS.

- `resolve(value)` — se o código roda normalmente, vai retornar o "value"
- `reject(error)` — se algum erro ocorre, "error" is the error object

Quando você cria uma "promise" usando new Promise, você tem "estados" e "resultados"
inicialmente o "state" é pendente -> se tudo ocorre bem: "fulfilled" -> se não: "rejected"
inicialmente o "result" é undefined -> se tudo ocorre bem passa a ser o value de resolve(value) -> se não, é o erro de reject(error).
OBS: só pode existir um "resolve" ou um "reject" mas você pode escrever os dois sem problemas, desde que você faça uma condional.

```js
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve(alert("done")), 1000);
}
```

#### methods de propagação:

Você já tem a ata, e já produziu a musica, agora você só precisa enviar ela para os fãs, mas como?
Usando um dos methods: .then, .catch, .finally
O ".then" é o mais usado/universal. Você usa da seguinte forma:

```js
alert("inicio do código");
let promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve("result"), 2000);
});
promise.finally(() => alert("Promise ready"));
promise.then((result) => alert(result)); // <-- .then handles the result
```

Vamos usar promises para reescrever o exemplo do carregamento de scripts, que usavam callbacks.

```js
function loadScript(src) {
  return new Promise(function (resolve, reject) {
    let script = document.createElement("script");
    script.src = src;
    //basicamente, podemos escrever as duas. Mas devemos fazer uma espécie de condicional
    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error(`Script load error for ${src}`));

    document.head.append(script);
  });
}

let promise = loadScript(
  "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"
);

promise.then(
  (script) => alert("O script foi carregado"),
  (error) => alert(`O seguinte erro aconteceu: ${error.message}`)
);
promise.finally(() => alert("finalização do processo"));
```

#### promise chaining:

Se você tem uma sequencia de processos assíncronos e quer interligar eles, com promises você faz isso de maneira simples. Basta chamar o ".then" dessa promessa. Repare que não existe "espaços" entre os .then. Eles estão: .then().then().then().then().then()

##### fetch example:

Normalmente promises são usadas em network requests e você pode trabalhar com elas de diversas maneiras. Vamos ver um modo "vanilla" de lidar com o http request "fetch".
let promise = fetch(url); vai fazer uma request dada uma url e vai resolver(retornar) uma resposta incompleta (uma confirmação de conexão) e depois uma completa (com os dados).

```js
//criando um user
let user = {
  name: "dFLPp",
};
//fazendo uma request ao github
fetch(`https://api.github.com/users/${user.name}`)
  // carregando a respose em .json
  .then((response) => response.json())
  .catch((err) => alert(err)) //opcional mas importante.
  // mostrando a imagem do perfil do user no github por 3s
  .then((githubUser) => {
    let img = document.createElement("img");
    img.src = githubUser.avatar_url;
    document.body.append(img);

    setTimeout(() => img.remove(), 3000);
  });
```

### Async/await:

É um modo mais simples de se escrever promessas.
Usa-se a keyword `async` na frente de uma função para dizer que ela Sempre retorna uma promessa. No exemplo a seguir percebe-se que a função passa a ser assíncrona

```js
async function f() {
  return 1;
}
f().then(alert);
```

Usar async é mais simples/menos confuso pois, como todas as funções declaradas com async retornam necessáriamente uma promessa, podemos usar "return 1" ao invés de return Promise.resolve(1);
Existe ainda a keyword "await". Ela só pode ser usada dentro de funções que são "async" e ela faz o javaScript pausar a execução de algo até que a promessa returne algo.
Não é obrigatorio, mas na maioria das vezes, você deve usar: "let a = await ..." ao invés de usar "await ..." diretamente.

```js
async function f() {
  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("done!"), 1000);
  });
  let result = await promise; // a execução da função Para aqui e só volta quando a promise retornar algo.
  alert(result); // "done!"
}
f();
```

Usando async/await vamos tentar reconstruir aquele exemplo de mostrar o icone do github de um user.

```js
let user = {
  name: "dFLPp",
};

async function showAvatar(name) {
  //faz a request
  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  //"traduz" a request em json usável pelo código
  let githubUser = await githubResponse.json();

  //mostra o ícone no html
  let img = document.createElement("img");
  img.src = githubUser.avatar_url;
  img.className = "promise-avatar-example";
  document.body.append(img);

  //espera 3s para apagar o icone
  await new Promise((resolve, reject) => setTimeout(resolve, 3000));
  img.remove();
  return githubUser;
}

showAvatar(user.name);
```

#### Error handling:

Quanto estamos trabalhando com async/await nós estamos dentro de funções, então é mais prático e fácil usar o try..catch ao invés de usar o .catch (como acontecia em promises).

```js
async function f() {
  try {
    let response = await fetch("/no-user-here");
    let user = await response.json();
  } catch (err) {
    // catches errors both in fetch and response.json
    alert(err);
  }
}

f();
```

## Modules:

Modules são arquivos que podem ser importados, permitindo usar códigos em outros arquivos sem ter que entende-los ou reescreve-los
Ex: eu tenho dois arquivos no mesmo diretório: sayHi.js e main.js. Se eu quiser usar uma função, ou uma variável, generators ou etc, eu preciso exportar ela (export)
Já em "main.js" eu quero usar algo não nativo, então eu preciso importar (import)

```js
// 📁 sayHi.js
export function sayHi(user) {
  alert(`Hello, ${user}!`);
}

// 📁 main.js
import { sayHi } from "./sayHi.js";
sayHi("John"); // Hello, John!
```

Existem alguns outros tópicos:

- `import *` vai importar todas as coisas que foram exportadas no arquivo alvo
- tanto no export quanto no import você pode utilizar "as" para se referir a uma função ou coisa específico.
- import deve estar no "top level" (não pode estar funções, condicionais, blocos de código no geral)

```js
// 📁 say.js
export function sayHi() { ... }
export function sayBye() { ... }
export function becomeSilent() { ... }

// 📁 main.js
import * as say from './say.js';

say.sayHi('John');
say.sayBye('John');
```

### Build tools:

Em projetos reais, normalmente não se utilizam modules na sua versão "Pura", uma ferramenta chamada de bundler vai organizar e otimizar os modules de modo que não ocorram erros e que o app/site não fique pessado.
Por exemplo, supondo que nós utilizamos a bundler "Webpack", ao invés de fazer vários imports no html ou em outro .js, Nos podemos fazes esses vários imports no arquivo especial do Webpack e ele então vai otimizar o código.
Dessa forma ao invés de fazer 5 imports no meu html, eu faço somente 1 (que é o arquivo especial fornecido pelo bundler)

### Dynamic imports:

Tem sentido literal. O intúito é fazer o import de modules ou files de maneira "ao vivo" (on-demand), sendo necessário usar o method "import()".
Na maioria das vezes, se você quer carregar um import em um momento específico, é poque você está usando async. Veja o exemplo que combina os dois conceitos:

```js
// 📁 say.js
export function hi() {
alert(`Hello`);
}
export function bye() {
alert(`Bye`);
}
export default function() {
alert("Module loaded (export default)!");
}

// 📁 index.html

<!doctype html>
<script>
  async function load() {		// só se pode usar await em função async
    let say = await import('./say.js'); // você faz await no "import()";
    say.hi(); // Hello!
    say.bye(); // Bye!
    say.default(); // Module loaded (export default)!
  }
</script>

<button onclick="load()">Click me</button>

```

## Conclusão

Agora que você já sabe o básico da sintaxe de javascript já pode começar a integra-lo com HTML. Para isso é só olhar as próximas anotações. Caso tenha dúvidas ou queira pesquisar mais sobre abaixo estão alguns links úteis:

- [MDN docs](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript)
- [Javascript info](https://javascript.info/)
